package evaluation

type cell struct {
  val int
}

requires acc(x.val) && acc(y.val)
requires x.val == a && y.val == b
ensures acc(x.val) && acc(y.val)
ensures x.val == b && y.val == a
func swap1(x *cell, y *cell, ghost a int, ghost b int)() {
  x.val, y.val = y.val, x.val

}

requires acc(x.val) && acc(y.val)
ensures acc(x.val) && acc(y.val)
ensures x.val == old(y.val) && y.val == old(x.val)
func swap2(x *cell, y *cell) () {
  x.val, y.val = y.val, x.val

}

requires acc(self.val) && acc(other.val)
ensures acc(self.val) && acc(other.val)
ensures self.val == old(other.val) && other.val == old(self.val)
func (self *cell) swap3(other *cell) () {
  self.val, other.val = other.val, self.val
}

func client() () {
  x!, z := cell { 42}, cell { 12}
  y! := cell { 17}
  swap1(&x, &y, 42, 17)
  assert x == cell { 17} && y.val == 42
  swap2(&x, &y)
  assert x == cell { 42} && y == cell { 17}
  (&x).swap3(&y)
  assert x == cell { 17} && y == cell { 42}
}

ensures y == x + 42;
func foo(x int) (y int) {
	return x + 42;
};

requires x >= 0;
ensures y >= 0
func fib(x int) (y int) {
	if x == 0 {
		return 0;
	} else if x == 1 {
		return 1;
	} else {
		a, b := fib(x-1), fib(x-2);
		return a + b;
	};
};