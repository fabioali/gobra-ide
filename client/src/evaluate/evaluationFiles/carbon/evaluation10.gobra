package evaluation

type cell struct {
  val int
}

type node struct {
  value int;
  next *node;
};

requires acc(x.val) && acc(y.val)
requires x.val == a && y.val == b
ensures acc(x.val) && acc(y.val)
ensures x.val == b && y.val == a
func swap1(x *cell, y *cell, ghost a int, ghost b int)() {
  x.val, y.val = y.val, x.val

}

requires acc(x.val) && acc(y.val)
ensures acc(x.val) && acc(y.val)
ensures x.val == old(y.val) && y.val == old(x.val)
func swap2(x *cell, y *cell) () {
  x.val, y.val = y.val, x.val

}

requires acc(self.val) && acc(other.val)
ensures acc(self.val) && acc(other.val)
ensures self.val == old(other.val) && other.val == old(self.val)
func (self *cell) swap3(other *cell) () {
  self.val, other.val = other.val, self.val
}

func client() () {
  x!, z := cell { 42}, cell { 12}
  y! := cell { 17}
  swap1(&x, &y, 42, 17)
  assert x == cell { 17} && y.val == 42
  swap2(&x, &y)
  assert x == cell { 42} && y == cell { 17}
  (&x).swap3(&y)
  assert x == cell { 17} && y == cell { 42}
}

ensures y == x + 42;
func foo(x int) (y int) {
	return x + 42;
};

requires x >= 0;
ensures y >= 0
func fib(x int) (y int) {
	if x == 0 {
		return 0;
	} else if x == 1 {
		return 1;
	} else {
		a, b := fib(x-1), fib(x-2);
		return a + b;
	};
};

requires x >= 0;
ensures  z == x*y;
func test(x, y int) (z int) {

	invariant z == i*y;
	invariant i <= x;
	for i := 0; i < x; i += 1 {
		z += y;
	};
};

requires 0 <= n;
ensures 2 * r == n * (n+1);
func sum(n int) (r int) {
  invariant 2 * r == (i-1) * i;
  invariant i <= n + 1;
  for i := 0; i <= n; i++ {
    r += i;
  };
};

requires 0 <= n;
ensures 6 * r == n * (n+1) * (2*n+1);
func sum_sq (n int) (r int) {
  invariant 6 * r == i * (i-1) * (2*i-1);
  invariant i <= n + 1;
  for i := 0; i <= n; i++ { r += i * i; };
};

requires 0 <= n;
ensures 4 * r == n * n * (n+1) * (n+1);
func sum_cb (n int) (r int) {
  invariant 4 * r == (i-1) * (i-1) * i * i;
  invariant i <= n + 1;
  for i := 0; i <= n; i++ { r += i * i * i; };
};

requires 0 <= n;
ensures r == n * n * n * n * n * n * n * n;
func power_8_linearly (n int) (r int) {
  p1, p2, p3, p4, p5, p6, p7, p8 := 0, 0, 0, 0, 0, 0, 0, 0;
  invariant p1 == i;
  invariant p2 == i * p1;
  invariant p3 == i * p2;
  invariant p4 == i * p3;
  invariant p5 == i * p4;
  invariant p6 == i * p5;
  invariant p7 == i * p6;
  invariant p8 == i * p7;
  invariant i <= n;
  for i := 0; i < n; i++ {
    p8 += 8 * p7 + 28 * p6 + 56 * p5 + 70 * p4 + 56 * p3 + 28 * p2 + 8 * p1 + 1;
    p7 += 7 * p6 + 21 * p5 + 35 * p4 + 35 * p3 + 21 * p2 + 7 * p1 + 1;
    p6 += 6 * p5 + 15 * p4 + 20 * p3 + 15 * p2 + 6 * p1 + 1;
    p5 += 5 * p4 + 10 * p3 + 10 * p2 + 5 * p1 + 1;
    p4 += 4 * p3 + 6 * p2 + 4 * p1 + 1;
    p3 += 3 * p2 + 3 * p1 + 1;
    p2 += 2 * p1 + 1;
    p1++;
  };
  r = p8;
};

pred infList(headPtr *node) {
  headPtr != nil && acc(headPtr.value) && acc(headPtr.next) && infList(headPtr.next)
};


requires infList(ptr);
requires n >= 0;
ensures infList(ptr);
func nth(ptr *node,n int) int {
  unfold infList(ptr);
  if(n == 0) {
    r := ptr.value;
    fold infList(ptr)
    return r;
  } else {
    r := nth(ptr.next,n-1);
    fold infList(ptr);
    return r;
  };
};